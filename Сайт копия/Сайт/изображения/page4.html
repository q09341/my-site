<!DOCTYPE html>
<html>
<head>
    <title>Ранние методы и интерфейсы доступа к данным</title>
</head>
<body bgcolor="#FFD7D6">
    
<h3>Ранние методы и интерфейсы доступа к данным</h3>
<p>
Первые системы управления базами данных появились еще в 60-70-х годах, они были основаны на иерархической и сетевой моделях данных. Примером иерархической модели СУБД является IBM IMS (Information Management System), состоящая из двух компонентов: IMS DB (Database Manager) – для хранения и управления данными; IMS TM (Transaction Manager) – для обработки транзакций в реальном времени, и разработанная совместно с NASA для программы «Аполлон».
</p>

<p>
Практический пример использования этой модели СУБД представлен в банковской системе для обработки транзакций банкоматов. IMS Database хранит данные клиентов и счетов в иерархической структуре, например: Корневой сегмент: Информация о клиенте (ID клиента, имя, номер счета); Дочерний сегмент: Сведения о счете (тип счета, баланс); Дочерний сегмент второго уровня: История транзакций (дата, сумма, тип операции – снятие или пополнение), визуальный пример структуры – рис. 1. Далее происходит обработка транзакции (снятие денег через банкомат) – в первую очередь банкомат отправляет запрос (ID клиента, сумма) в IMS TM, затем IMS TM ставит запрос в очередь, приложение (на COBOL/Java) проверяет баланс через IMS DB, обновляет его, после чего IMS TM записывает все детали транзакции в специальный журнал – лог, и отправляет подтверждение в банкомат.
</p>

<center><img src="IMS.png" width="500" height="150"></center>
<br><center>Рис. 1 - Структура базы данных в IMS.</center>

<p>
Сетевая модель данных позволяет создавать сложные связи между данными, где один элемент может быть связан с несколькими другими. Примером такой СУБД является CODASYL DBTG (Conference on Data Systems Languages Data Base Task Group), предложенная в 1969 году, где записи связаны через множества, а не иерархии, как в IMS.
</p>

<p>
Пример использования сетевой модели представлен в библиотечной системе для управления книгами, читателями и выдачей книг. Структура данных включает: Записи – читатель (ID читателя, Имя, Адрес), книга (ID книги, Название, Автор), выдача (Дата выдачи, Дата возврата); Множества – читатель-выдача (связывает читателя с его выдачами), книга-выдача (связывает книгу с записями о выдаче). Для наглядности: Читатель (ID: R001, Имя: Анна) берет книгу (ID: B001, Название: «Война и мир»). Связь: Множество «Читатель-Выдача» указывает, что у Анны есть выдача, а «Книга-Выдача» - что книга «Война и мир» выдана (визуальный пример структуры - рис. 2). Обработка операции выглядит следующим образом: Добавление выдачи: система создает запись «Выдача» (Дата выдачи), связывает её с читателем R001 через множество «Читатель-Выдача», связывает с книгой B001 через множество «Книга-Выдача»; Поиск: чтобы узнать, какие книги у Анны, система проходит через множество «Читатель-Выдача» и находит все выдачи, затем через «Книга-Выдача» получает данные о книгах.
</p>

<center><img src="CODASYL.png" width="500" height="150"></center>
<br><center>Рис. 2 - Структура базы данных в CODASYL DBTG</center>

<p>
В 1970 году Эдгар Кодд предложил реляционную модель данных, которая легла в основу современных СУБД. Данные стали храниться в виде таблиц. Основные понятия реляционной модели данных включают: Отношение (relation) - таблица; Заголовок отношения – набор атрибутов (столбцов), каждый из которых имеет уникальное имя и тип данных; Тело отношения – множество кортежей (строк), представляющих конкретные данные.
</p>

<table border="1" align="center">
    <tr>
        <th>Student_ID</th>
        <th>Name</th>
        <th>Group</th>
    </tr>
    <tr>
        <td>289001</td>
        <td>Петр Иванович</td>
        <td>P3110</td>
    </tr>
    <tr>
        <td>289002</td>
        <td>Иван Петрович</td>
        <td>P3130</td>
    </tr>
</table>
<br><center>Табл. 1 - Визуализация отношения в реляционной СУБД.</center>

<p>
К основным свойствам отношений относятся: Каждый атрибут имеет тип данных, и его значение должно соответствовать этому типу; Атрибуты не повторяются, их порядок не важен; Кортежи также не должны повторяться, их порядок не важен; Каждое отношение имеет первичный ключ, который однозначно идентифицирует каждую строку. Для обеспечения корректности и согласованности данных применяются различные ограничения и правила целостности данных.
</p>

<p>
Типы данных для столбцов включают:<br>
- <strong>Int, bigint</strong> – целые числа;<br>
- <strong>Float, double</strong> – дробные числа;<br>
- <strong>Char(n), varchar(n)</strong> – текстовые поля;<br>
- <strong>Date, datetime</strong> – временные данные.<br>
<br>Также существуют некоторые ограничения значений, пример использования в SQL которых представлен на рис.3:<br>
- <strong>Not null</strong> – значение не может быть пустым;<br>
- <strong>Unique</strong> – значения в столбце должны быть уникальными;<br>
- <strong>Check (condition)</strong> – проверка условия при вставке / обновлении.
</p>

<center><img src="type.png" width="600" height="150"></center>
<br><center>Рис. 3 - Пример использования ограничений и назначение типов данных</center>
<br>
В данном примере таблица `courses` создаётся для хранения данных о курсах с полями: `course_id` (уникальный ключ, целое число), `name` (название, до 50 символов), `semester` (семестр, целое число от 1 до 10), и `type` (тип курса, до 10 символов). Ограничения `PRIMARY KEY` - первичный ключ: столбец или совокупность столбцов, идентифицирующая запись. Значение первичного ключа не может быть Null, и должно быть уникальным; `CHECK` - проверка условия при вставке / обновлении. Они обеспечивают целостность данных.<br>
<br>
Стоит отметить, что реляционная модель данных поддерживает два типа целостности: <br>
-	<strong>Целостность сущностей</strong>: гарантируется с помощью первичных ключей – каждая запись должна иметь уникальный и непустой идентификатор.<br>
-	<strong>Ссылочная целостность</strong>: обеспечивается внешними ключами – нельзя добавить запись с несуществующим значением внешнего ключа.<br>

<center>
    <a href="page3.html" target="window-1">Предыдущая страница</a> |
    <a href="page5.html" target="window-1">Следующая страница</a>
</center>

</body>
</html>