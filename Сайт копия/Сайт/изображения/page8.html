
<html>
<head>
    <title>Новые тенденции и нетрадиционные методы работы с БД</title>
</head>
<body bgcolor="#FFD7D6">
<h3>Новые тенденции и нетрадиционные методы работы с БД</h3>
<p>Использование нереляционных баз данных стало актуальным из-за потребности в параллельных распределенных системах для высокомасштабируемых приложений, например, поисковые системы. Этот подход применялся еще со времен первых ЭВМ в специализированных хранилищах, например, в иерархических службах каталогов и реестрах, и получил общее название NoSQL («не только SQL»). </p>
Традиционные СУБД ориентированы на транзакционные требования: атомарность, согласованность, изолированность и долговечность. В NoSQL используется другой набор свойств, а именно: Базовая доступность (каждый запрос гарантированно завершается); Гибкое состояние (состояние системы может изменяться со временем, даже без ввода новых данных для согласования данных); Согласованность в конечном счете (данные могут быть некоторое время рассогласованы, но приходят к согласованию спустя какое-то время). NoSQ-решения не подходят для всех систем: например, биржевые и банковские службы требуют строгих транзакций. Однако некоторые реализации этого подхода позволяют настраивать баланс доступности и согласованности, задавая количество узлов для подтверждения транзакции.
<p>Особенности NoSQL включают не только проектирование с учетом масштабирования, другими характерными чертами являются: применение различных типов хранилищ, возможность разработки БД без задания схемы, линейная масштабируемость (производительность увеличивается с добавлением процессорных ресурсов), инновационность.</p>
Существует несколько типов NoSQL-систем:<br>
1.	Хранилища «ключ-значение»;<br>
2.	Документоориентированные хранилища;<br>
3.	Графовые хранилища;<br>
4.	Колоночные хранилища.
<p>Хранилища «ключ-значение» являются простейшими, представляя собой ассоциативный массив, где каждому значению соответствует уникальный ключ, что делает их подходящими для хранения данных веб-сессий или профилей пользователей, но затрудняет сложные операции, такие как поиск по значениям. Документоориентированные хранилища хранят данные в виде иерархических документов, идеально подходящих для независимых данных, например, в каталогах товаров или форумах, но неэффективны для задач с множеством связей. Графовые хранилища, напротив, отличаются сильными связями между узлами и подходят для анализа взаимосвязей, таких как социальные сети или геолокационные сервисы, где узел графа будет обозначать географическую точку, отношение — расстояние. Колоночные хранилища хранят данные в виде столбцов, а не строк, что делает их подходящими для задач журнализации и архивирования больших объёмов данных, обеспечивая высокую скорость многопоточной записи.</p>
<strong>GraphQL</strong> – это язык запросов и серверная среда для API с открытым исходным кодом. Он появился в Facebook в 2012 году и был разработан для упрощения управления конечными точками для API на основе REST API («Representational State Transfer» - «передача репрезентативного состояния»,  это архитектурный подход, который устанавливает ограничения для API: как они должны быть устроены и какие функции поддерживать.). В 2015 году код GraphQL стал открытым, и сейчас его используют AirBnb, GitHub, Pinterest и многие другие компании. 
<br>Среди основных проблем REST, которые решает GraphQL, выделяют следующие:<br>
1.	<strong>Избыточность или недостаток данных в ответе</strong> – GraphQL позволяет клиентам запрашивать только те данные, которые им нужны, и получать их в одном запросе, что делает коммуникацию более эффективной.<br>
2.	<strong>Проблемы с расширяемость и поддержкой разных версий API</strong> – В GraphQL существует единая конечная точка для всех запросов, и схема API определяется на стороне сервера. Это делает API более гибким и облегчает его развитие.<br>
3.	<strong>Проблема «N+1» запросов</strong> – GraphQL позволяет выразить связи между данными и получать все необходимые данные в одном запросе.<br>
В GraphQL существует несколько типов запросов: Query – используется для получения данных с сервера, это аналог GET в REST; Mutation – используется для изменения данных на сервере. Это аналог POST и PUT в REST; Subscription – позволяет клиенту слушать изменения в БД в режиме реального времени.
<p>Также необходимо разобраться как называть и организовывать элементы, использующиеся в GraphQL. В запросах GraphQL существуют некоторые концепции: Поля (Fields) – поля представляют собой единицы запрашиваемых данных; Аргументы (Arguments) = позволяют передавать параметры в запросы; Псевдонимы (Aliases) – используются для переименовывания полей в ответе запроса; Фрагменты (Fragments) – позволяют разделять сложные требования к данным; Переменные (Variables) – позволяют динамически указывать значения; Директивы (Directives) – помогают динамически изменять структуру и форму запросов.</p>
Необходимо разобраться как использовать  GraphQL на практическом примере. Постановка задачи: получить список пользователей и последние посты каждого из них. Запрос представлен на рис. 33.
<p><center><img src = "graph.png" width = "200" height = "130"></center></p>
<center>Рис. 33 – Пример запроса на GraphQL.</center>
<br>Вывод представлен на рис. 34.
<p><center><img src = "p34.png" width = "300" height = "180"></center></p>
<center>Рис. 34 – Вывод запроса, написанного на GraphQL.</center>
<br>Данный пример показывает, как GraphQL позволяет получить сложные, вложенные данные за один запрос, в то время как в REST потребовалось бы минимум два отдельных запроса.
    <center>
        <a href="page7.html" target="window-1">Предыдущая страница</a> |
        <a href="page9.html" target="window-1">Следующая страница</a>
    </center>

</body>
</html>