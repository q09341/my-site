
<html>
<head>
    <title>Современные подходы и инструменты взаимодействия с БД</title>
</head>
<body bgcolor="#FFD7D6">
    <h3>Современные подходы и инструменты взаимодействия с БД</h3>
    Современные подходы к взаимодействию с базами данных значительно эволюционировали, предлагая разработчикам более эффективные и удобные инструменты по сравнению с традиционными методами, такими как прямое использование SQL или API вроде ODBC и JDBC. Среди них особое место занимают объектно-реляционные мапперы (ORM), которые упрощают работу с данными, абстрагируя сложность низкоуровневого доступа к БД. Наиболее популярными ORM являются Django ORM, Eloquent ORM и SQLAlchemy, а также легковесные ORM-библиотеки.<br>
    <p>
        <strong>ORM (Object-Relational Mapping, обхектно-реляционное отображение)</strong> — это технология, которая позволяет разработчикам взаимодействовать с базами данных, представляя данные как объекты языков программирования. ORM выступает прослойкой между базой данных и кодом, упрощая этот процесс: разработчик может создать объект в программе и записать его в базу или, наоборот, получить данные из базы и работать с ними как с объектом. Без ORM разработчику пришлось бы использовать SQL напрямую или вручную преобразовывать данные из базы в объекты. ORM автоматизирует этот процесс: программист пишет запрос на языке программирования, а ORM сопоставляет свойства объекта с полями базы, формируя SQL-запрос. Таким образом, разработчику не нужно писать SQL или заниматься переводом данных — ORM делает это автоматически, снимая лишнюю нагрузку. Его архитектура представлена на рис. 12.
    </p>
<p><center><img src = "orm_example.jpg" width = "400" height = "150"></center></p>
<center>Рис. 12 – Архитектура ORM.</center>
Компоненты архитектуры ORM включают: Приложение – это клиентская часть программы, которая использует ORM для взаимодействия с базой данных. ORM Layer – слой маппинга, преобразующий объекты в запросы к БД и обратно. SQL Generator -> Database Adapter – SQL Generator создает SQL-запросы, Database Adapter адаптирует их для конкретной СУБД. База данных – реляционная СУБД, где хранятся данные.<br>
Назначение ORM — упростить работу с БД, устранить необходимость ручного написания SQL и обеспечить переносимость кода; особенности включают абстракцию SQL, поддержка миграции (механизм изменения схемы БД без написания SQL вручную), кросс-платформенность, но с возможными накладными расходами (дополнительные затраты ресурсов, возникающие при преобразовании сложных операций с данными, что снижает производительность и увеличивает потребление памяти) при сложных запросах.<br>
Пример модели с использованием библиотеки SQLAlchemy на Python представлен на рис. 13, а пример запроса с использованием ORM изображен на рис. 14:
<p><center><img src = "sqlal.png" width = "400" height = "200"></center></p>
<center>Рис. 13 – Модель на языке программирования Python с использованием библиотеки SQLAlchemy.</center>
<br>В данной модели создается таблица ‘courses’ с полями id (ключ), name (строка), semester (число).
<p><center><img src = "porm.png" width = "550" height = "200"></center></p>
<center>Рис. 14 – Запрос на языке программирования Python с использованием ORM.</center>
<br>В этом запросе Session(engine) – создает ORM-сессию, session.query(Course) – строит запрос через ORM, преобразует в SQL, .filter(Course.semester == 3) – фильтрует в объектном стиле, .all() – возвращает объекты в Course. Этот запрос извлекает все курсы с семестром 3 и выводит их названия.   
<p>
    <strong>Django ORM (Object-Relational Mapping)</strong> является конкретной реализацией ORM для Python-фреймворка Django, которая значительно упрощает взаимодействие с базами данных для разработчиков веб-приложений. Django ORM позволяет работать с базами данных, используя Python-код вместо прямых SQL-запросов, что делает процесс более интуитивным и менее подверженным ошибкам. Это особенно важно в условиях, когда разработчики стремятся ускорить разработку и повысить её качество. Архитектура Django ORM представлена на рис.15.
</p>
<p><center><img src = "django.png" width = "300" height = "180"></center></p>
<center>Рис. 15 – Архитектура Django ORM.</center>
<br>Компоненты архитектуры: Приложение на Python – клиентский уровень, где описывается бизнес-логика; Django ORM Layer – обеспечивает работу с данными через объекты и методы; QuerySet API – высокоуровневый интерфейс для работы с данными; SQL Generator преобразует вызовы ORM в SQL-запросы; Backend адаптер СУБД отвечает за выполнение SQL-запросов в конкретной СУБД; Реляционная СУБД – хранение и обработка данных.
<br>Процесс взаимодействия с базой данных через Django ORM включает следующие этапы: Настройка соединения; Определение моделей – модели создаются в файле, представляя таблицы БД; Построение запросов – используются методы ORM, которые генерируют SQL-запросы; Выполнение запросов – Django отправляет запросы в БД и возвращает данные в виде объектов Python; Сохранение изменений – изменения фиксируются, что синхронизирует объекты с БД.
<br>Назначение Django ORM заключается в упрощении работы с БД, минимизации ручного написания SQL и обеспечении переносимости кода между различными СУБД. Это особенно полезно для веб-разработки, где требуется быстрое создание приложений с минимальными затратами на управление данными. Мигранты, как часть ORM, позволяют эволюционировать схему БД без потери данных.
<br>Пример модели в models.py на Python представлен на рис. 16, а пример запроса представлен на рис. 17.
<p><center><img src = "modelspy.png" width = "550" height = "120"></center></p>
<center>Рис. 16 – Модель в models.py на языке программирования Python.</center>
<br>Эта модель представляет таблицу ‘courses’ с полями ‘name’ и ‘semester’.
<p><center><img src = "sapr.png" width = "550" height = "100"></center></p>
<center>Рис. 17 – Запрос на языке программирования Python.</center>
<br>Данный запрос выводит названия курсов с семестром 3, демонстрируя, как ORM упрощает фильтрацию без написания SQL.
<p>
    <strong>Eloquent ORM</strong> – это ORM, встроенный в Laravel (бесплатный PHP-фреймворк с открытым исходным кодом, специально разработанный для создания сложных сайтов и веб-приложений; PHP – скриптовый язык программирования), который позволяет разработчикам работать с базами данных, используя объектно-ориентированный подход, реализуя шаблон Active Record. Он предоставляет возможность работы с базами данных через модели, которые представляют собой классы, соответствующие таблицам в базе данных. Архитектура взаимодействия Eloquent ORM с БД представлена на рис. 18.
</p>
<p><center><img src = "eloquent.png" width = "500" height = "150"></center></p>
<center>Рис. 18 – Архитектура Eloquent ORM.</center>
<br>Основные компоненты этой архитектуры: <br>
1.	Модели – ключевой элемент, управляющий процессом. Это классы, предоставляющие таблицы БД, инициируют запросы и получают результаты;<br>
2.	Eloquent ORM – центральный компонент, генерирует SQL-запросы и обрабатывает данные, интегрирован с Laravel;<br>
3.	DB Connection – обеспечивает связь между Eloquent ORM и базой данных, передает SQL-запросы и возвращает результаты;<br>
4.	База данных – хранилище данных, где СУБД интерпретирует и выполняет переданные SQL-запросы (Execute SQL) через оптимизированный процесс, возвращая данные.
<p>
    Eloquent ORM – это реализация паттерна Active Record, встроенная в PHP-фреймворк Laravel. В Eloquent ORM шаблон Active Record означает, что таблицы базы данных представлены как классы, а строки — как объекты этих классов. Она предназначена для упрощения взаимодействия с реляционными базами данных на уровне объектов, автоматизации операций CRUD (Create, read, Update, Delete), описания и обработки связей между таблицами, а также Eloquent абстрагирует разработчика от написания SQL вручную, позволяя работать с данными через модели. В отличие от других ORM, Eloquent предлагает более интуитивно понятный и лёгкий способ работы с данными, что делает его особенно популярным в веб-разработке на PHP. 
</p>
<p>
    В Laravel каждая модель представляет собой класс, который наследуется от «Illuminate\Database\Eloquent\Mode»l. Модель связана с таблицей в базе данных, имя которой определяется автоматически — как множественное число названия класса (например, модель «Student» связывается с таблицей «students»). Пример модели представлен на рис. 19.
</p>
<p><center><img src = "laravel.png" width = "400" height = "150"></center></p>
<center>Рис. 19 – Пример модели в Laravel.</center>
<br>В данной модели класс «Student» представляет таблицу «students». Метод «group()» описывает отношение "принадлежит" (belongsTo) к таблице «groups» по внешнему ключу «group_id». 
<br>Перед запросом необходимо поставить задачу, например: Получить всех студентов из группы P3110 и вывести их имя и факультет. Пример запроса представлен на рис. 20.
<p><center><img src = "elp.png" width = "400" height = "100"></center></p>
<center>Рис. 20 – Пример запроса с использованием Eloquent ORM в Laravel.</center>
<br>Этот код выполняет SQL-запрос, представленный на рис. 21.
<p><center><img src = "sql.png" width = "350" height = "20"></center></p>
<center>Рис. 21 – Выполнение SQL-запроса.</center>
<br>А при обращении к «$student->group->faculty» происходит загрузка связанной таблицы «groups».
<br>Работает это следующим образом: модель — класс ‘Student’, описывающий структуру таблицы ‘students’ и связи с другими таблицами; запрос — вызов метода ‘where('group', 'P3110')’ формирует условие SQL-запроса; генерация SQL — ORM преобразует вызов в SQL-запрос через ‘QueryBuilder’; выполнение — запрос отправляется в СУБД через драйвер; обработка результатов — результаты конвертируются в объекты ‘Student’; при обращении к ‘$student->group’ Eloquent автоматически загружает данные из связанной таблицы ‘groups’.
<p>SQLAlchemy — это Python-библиотека, которая позволяет работать с реляционными базами данных с помощью ORM. SQLAlchemy состоит из двух отдельных компонентов, известных как Core и ORM, архитектура представлена на рис. 22.</p>
<p><center><img src = "sqlalchemy.png" width = "350" height = "200"></center></p>
<center>Рис. 22 – Архитектура SQLAlchemy.</center>
<p>
    Среди основных компонентов: SQLAlchemy Core – ядро (Core) само по себе является полнофункциональным набором инструментов абстракции SQL, обеспечивающим плавный уровень абстракции для широкого спектра реализаций и вариантов поведения DBAPI (Database API – стандартный интерфейс Python для взаимодействия с базами данных, это низкоуровневый API, который SQLAlchemy использует для связи с конкретной СУБД), а также языка выражений SQL, который позволяет выражать язык SQL с помощью генеративных выражений Python. На рис.22 схематически показано из чего состоит Core. Это схема, типы, язык выражений SQL (SQL Expression Language ), Engine, это все поверх DBAPI; SQLAlchemy ORM — это объектно-реляционный маппер (Object Relational Mapper), который предоставляет высокоуровневый уровень абстракции для работы с базами данных через Python-объекты. Он строится поверх SQLAlchemy Core и позволяет разработчикам взаимодействовать с данными, представляя таблицы как классы, а строки — как экземпляры этих классов, избегая ручного написания сложных SQL-запросов.
</p>
<p>
    Основные этапы взаимодействия с БД через SQLAlchemy: Определение модели – создаются классы, представляющие таблицы в базе данных. Атрибуты классов соответствуют столбцам; Создание движка – устанавливается соединение с СУБД; Работа с сессией – через сессию выполняются операции над данными: добавление, обновление, удаление и выборка записей; Формирование и выполнение запроса – используя методы ORM или SQL-выражения, формируется запрос. Он выполняется только при необходимости; Обработка результатов – результаты возвращаются в виде объектов модели. Можно исользовать их атрибуты для дальнейшей логики; Транзакции и изменения – поддерживаются транзакции, миграции, пакетные операции; Завершение работы – сессия закрывается, изменения фиксируются, соединение освобождается.
</p>
<br>Данная библиотека предназначена для упрощения работы с базами данных, предоставляя ORM для объектного доступа и низкоуровневый интерфейс SQL, что позволяет эффективно управлять данными и минимизировать написание сложных запросов. Среди особенностей можно выделить следующие: гибкость (ORM и Core), поддержка асинхронности для современных приложений, кросс-платформенность, высокая настраиваемость. Пример модели на Python представлен на рис. 23.
<P><center><img src = "primer.png" width = "400" height = "150"></center></P>
<center>Рис. 23 – Пример модели на Python с использованием SQLAlchemy.</center>
<br>Модель ‘Student’ описывает таблицу ‘students’, где каждое поле соответствует столбцу в БД. Пример запроса на Python представлен на рис. 24.
<p><center><img src = "sapros.png" width = "500" height = "150"></center></p>
<center>Рис. 24 – Пример запроса на Python с использованием SQLAlchemy.</center>
<br>В данном примере создается сессия, выполняется запрос с соединением таблиц ‘students’ и ‘groups’, происходит фильтрация студентов по факультету  ‘ИСиТ, возвращение результата в виде объектов ‘Student’.
<p>Легковесные ORM библиотеки представляют собой упрощённые реализации объектно-реляционного отображения, которые обеспечивают минимальный уровень абстракции над SQL, при этом сохраняя читаемость кода и простоту использования. В отличие от более тяжёлых решений вроде Django ORM или SQLAlchemy, легковесные ORM ориентированы на низкий порог входа, минимальную конфигурацию, высокую производительность и гибкость в небольших проектах.</p>
<br>Среди наиболее популярных легковесных ORM библиотек можно выделить следующие: <br>
1.	<strong>Pewee (Python)</strong> - это легковесная ORM-библиотека для языка программирования Python, предназначенная для упрощения взаимодействия с реляционными базами данных. Она реализует паттерн Active Record, при котором каждый объект модели напрямую отображается на строку в таблице базы данных, а методы модели позволяют выполнять операции над данными без необходимости писать SQL вручную.<br>
2.	<strong>PonyORM</strong> – это легковесная ORM-библиотека для работы с реляционными базами данных на Python. Она предоставляет высокоуровневый интерфейс для создания, чтения, обновления и удаления записей, используя объектную модель , но при этом не навязывает сложной архитектуры, как это делают более тяжёлые ORM (например, SQLAlchemy или Django ORM).<br>
PonyORM предназначена для упрощения взаимодействия с реляционными базами данных в приложениях на Python, позволяя разработчикам работать с данными через объекты и методы Python, вместо написания SQL-запросов. Архитектура данной библиотеки представлена на рис. 25.
<p><center><img src = "pony.png" width = "400" height = "100"></center></p>
<center>Рис. 25 – Архитектура библиотеки PonyORM.</center>
<p>
    Компоненты архитектуры включают: Приложение - разработчики пишут код на Python, используя Pony ORM для взаимодействия с базой данных; PonyORM: Entity classes – Python-классы, которые представляют таблицы в базе данных, каждый атрибут класса соответствует столбцу таблицы; Database Session – управляет соединением с базой данных и обеспечивает транзакции; Query Builder – преобразует вызовы методов и атрибутов Python в SQL-запросы: Cache – кэширует объекты для повышения производительности; Database Abstraction Layer – обеспечивает взаимодействие с различными СУБД через унифицированный интерфейс; База данных – реляционная база данных, с которой взаимодействует PonyORM.
</p>
В Pony ORM взаимодействие с базой данных начинается с определения классов-сущностей, представляющих таблицы, затем настраивается соединение с базой данных, создается сессия для управления транзакциями, и выполняются операции создания, чтения, обновления и удаления записей, которые автоматически преобразуются в SQL-запросы. Пример модели представлен на рис. 26.
<p><center><img src = "ponyp.png" width = "300" height = "100"></center></p>
<center>Рис. 26 – Пример модели с использованием библиотеки PonyORM на Python.</center>
<br>Здесь 'Student' — модель, которая представляет собой строку из таблицы 'students'. Поле 'group' ссылается на другую модель 'Group'. Пример запроса представлен на рис. 27.
<p><center><img src = "saprpony.png" width = "320" height = "50"></center></p>
<center>Рис. 27 – Пример запроса на Python через PonyORM.</center>
PonyORM преобразует этот код в SQL-запрос, представленный на рис. 28.
<p><center><img src = "ponysql.png" width = "400" height = "80"></center></p>
<center>Рис. 28 – SQL-запрос, преобразованный PonyORM.</center>
<br>Данный запрос вернет все строки из таблицы ‘students’, связанные с группой «ИСиТ».
<br>Библиотека Peewee предназначена для работы с реляционными СУБД, удобного описания моделей и связей между ними, а также тестирования и прототипирования. Архитектура данной библиотеки представлена на рис. 29.
<p><center><img src = "pewe.png" width = "350" height = "100"></center></p>
<center>Рис. 29 – Архитектура библиотеки Peewee.</center>
<p>Среди основных компонентов: Приложение – разработчики пишут код на Python, используя Peewee для взаимодействия с базой данных; Models – класс, представляющий таблицу в БД; Database - управляет соединением с базой данных и предоставляет интерфейс для выполнения запросов; Query Builder - позволяет строить и выполнять SQL-запросы через Python-методы; Transactions - управляет транзакциями для обеспечения целостности данных; Абстракция базы данных – обеспечивает взаимодействие с различными СУБД через унифицированный интерфейс; База данных – Реляционная база данных, с которой взаимодействует Peewee.</p>
Процесс взаимодействия с базой данных с использованием библиотеки Peewee выглядит следующим образом: определение модели, создание соединения, выполнение запроса, генерация SQL, обработка результатов, закрытие соединения. Пример модели представлен на рис. 30.
<p><center><img src = "peewee.png" width = "250" height = "150"></center></p>
<center>Рис. 30 – Пример модели на Python с использованием Peewee.</center>
<br>Эта модель представляет таблицу ‘students’. Поле ‘name’ соответствует столбцу VARCHAR (аббревиатура от "variable character", что означает строка переменной длины), ‘group_id’ — внешний ключ на таблицу ‘groups’. Прмер запроса представлен на рис. 31.
<p><center><img src = "p31.png" width = "300" height = "70"></center></p>
<center>Рис. 31 – Пример запроса на Python через Peewee.</center>
<br>Этот код генерирует SQL-запрос, представленный на рис. 32.
<p><center><img src = "p32.png" width = "200" height = "20"></center></p>
<center>Рис. 32 – сгенерированный SQL-запрос.</center>
    <center>
        <a href="page6.html" target="window-1">Предыдущая страница</a> |
        <a href="page8.html" target="window-1">Следующая страница</a>
    </center>

</body>
</html>