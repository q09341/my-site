
<html>
<head>
    <title>Подключение к облачным базам данных и Steam-обработка данных</title>
</head>
<body bgcolor="#FFD7D6">
<h3>Подключение к облачным базам данных и Steam-обработка данных</h3>
<p>Необходимо также рассмотреть подключение к облачным БД. Облачные базы данных предоставляют возможность развертывания и управления реляционными базами данных в облачной инфраструктуре. Это позволяет организациям сосредоточиться на разработке приложений, не беспокоясь о физическом управлении серверами. С развитием облачных технологий всё чаще используются облачные реляционные СУБД, такие как: AWS RDS (Relational Database Service); Google Cloud SQL; Microsoft Azure SQL Database.</p>
<strong>AWS RDS</strong> — это облачный сервис баз данных, который поддерживает несколько движков, включая MySQL, PostgreSQL, Oracle и SQL Server. Он предоставляет функции автоматического резервного копирования, обновления программного обеспечения, мониторинга и масштабирования. Архитектура AWS RDS включает в себя: Приложение – клиентская часть системы, где выполняется бизнес-логика; Серверное приложение / ORM  - в этом слое происходит преобразование запросов от приложения в формат, понятный RDS; AWS RDS API / JDBC / ODBC – этот уровень обеспечивает интерфейс взаимодействия между приложением и RDS; AWS RDS Engine – это сердце архитектуры, здесь происходит автоматическое масштабирование, резервное копирование, мониторинг и оптимизация; Реляционная БД – физическая база данных, работающая на серверах AWS.
Для подключения к базе данных RDS необходимо использовать стандартные библиотеки для работы с базами данных, например, ‘psycopg2’ для PostgreSQL. Пример подключения через PostgreSQL представлен на рис. 35.
<p><center><img src = "p35.png" width = "230" height = "130"></center></p>
<center>Рис. 35 – Подключение к базе данных RDS через PostgreSQL.</center>
<p><strong>Azure SQL Database</strong> — это управляемая облачная база данных, основанная на Microsoft SQL Server. Она предоставляет встроенные функции безопасности, автоматическое резервное копирование и восстановление, а также интеграцию с другими сервисами Azure. Архитектура включает: Приложение – клиентский уровень, где разработчик или система взаимодействует с БД; API-интерфейс подключения; SQL Engine + Query Optimizer – это внутреннее ядро СУБД, отвечающее за выполнение SQL-запросов; База данных – данные организуются в логические «контейнеры»; Физическое хранилище данных в облаке - Azure SQL работает на основе Microsoft Azure Storage, где данные физически хранятся в виде разделённых файлов данных, распределённых по нескольким зонам доступности. </p>
Пример подключения к Azure SQL Database на Python с использованием SQLAlchemy представлен на рис. 36.
<p><center><img src = "p36.png" width = "650" height = "150"></center></p>
<center>Рис. 36 – Пример подключения к Azure SQL Database на Python.</center>
<p><strong>Google Cloud SQL</strong> — это полностью управляемая служба базы данных, совместимая с MySQL, PostgreSQL и SQL Server. Она обеспечивает автоматическое резервное копирование для надежности данных и восстановления на определенный момент времени. Cloud SQL также предлагает высокую доступность, реплицируя данные в несколько зон, и вертикальное масштабирование для регулирования производительности. Инструменты мониторинга и диагностики помогают отслеживать производительность и выявлять проблемы. Его архитектура включает: Приложение – клиентский уровень: веб-приложение/ микросервис / мобильное приложение; Cloud SQL API / Proxy – приложения взаимодействуют с Cloud SQL через API или прокси; Cloud SQL Engine – ядро системы, управляющее запросами к БД; Физическая БД – сам экземпляр базы данных, который хранится в Google Cloud; Облачное хранилище и сеть – данные физически хранятся в защищенном и шифрованном хранилище Google.</p>
Пример подключения к Google Cloud SQL через SQLAlchemy на Python представлен на рис. 37.
<p><center><img src = "p37.png" width = "300" height = "80"></center></p>
<center>Рис. 37 – Пример подключения к Google Cloud SQL.</center>
<br>В данном примере ‘my-project’ – проект в Google Cloud Platform, ‘region’ – регион размещения экземпляра, ‘instance-name’ – имя экземпляра Cloud SQL.
<p><strong>Stream-обработка данных</strong> — это метод обработки информации, при котором данные обрабатываются непрерывно по мере их поступления, а не накапливаются для пакетной обработки. Это позволяет анализировать информацию в реальном времени с минимальной задержкой. Ключевые характеристики Stream-обработки включают: обработку данных по мере их генерации, низкую задержку между поступлением данных и результатом обработки, работу с бесконечными потоками данных и необходимость горизонтального масштабирования. В отличие от пакетной обработки, где данные накапливаются и обрабатываются большими порциями, Stream-обработка работает с каждым событием индивидуально или небольшими окнами событий.</p>
Архитектура системы Stream-обработки включает несколько основных компонентов. Источники данных (Kafka, Kinesis, RabbitMQ и др.) генерируют или передают потоковые данные. Обработчики потоков (Flink, Spark Streaming, Storm и др.) получают эти данные и выполняют их трансформацию и анализ. Хранилища для результатов (базы данных, файловые системы) сохраняют обработанную информацию, а системы мониторинга и управления обеспечивают контроль над всем процессом. Взаимодействие между этими компонентами можно представить как цепочку: [Источники данных] → [Система сбора] → [Обработчик] → [Хранилище] → [Визуализация/Действия].
<p>Необходимо рассмотреть практическое применение данного подхода, для этого нужно поставить задачу. Постановка задачи: Обрабатывать входящие значения температуры в реальном времени и вычислять скользящее среднее. Решение на Python без внешних библиотек представлено на рис. 38.</p>
<p><center><img src = "p38.png" width = "450" height = "400"></center></p>
<center>Рис. 38 – Пример использования Steam-обработки данных на Python.</center><br>
    <center>
        <a href="page8.html" target="window-1">Предыдущая страница</a> |
        <a href="page10.html" target="window-1">Следующая страница</a>
    </center>

</body>
</html>